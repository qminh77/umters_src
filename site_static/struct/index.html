<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Danh sách liên kết - Demo tương tác hoàn chỉnh</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1500px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            box-shadow: 0 30px 60px rgba(0,0,0,0.2);
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 50px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        
        .header h1 {
            font-size: 3.5em;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: titleGlow 3s ease-in-out infinite alternate;
        }
        
        .header p {
            font-size: 1.3em;
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .nav-tabs {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }
        
        .tab-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .tab-btn.active {
            background: white;
            color: #667eea;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .content {
            padding: 50px;
        }
        
        .tab-content {
            display: none;
            animation: fadeInUp 0.6s ease-out;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section {
            margin-bottom: 60px;
            padding: 40px;
            background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(240,248,255,0.9));
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.5);
            position: relative;
            overflow: hidden;
        }
        
        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 200% 100%;
            animation: colorFlow 4s ease infinite;
        }
        
        .section-title {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 30px;
            text-align: center;
            position: relative;
            padding-bottom: 20px;
        }
        
        .section-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 2px;
        }
        
        .explanation {
            background: rgba(255,255,255,0.8);
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            border-left: 5px solid #3498db;
            box-shadow: 0 10px 25px rgba(0,0,0,0.05);
        }
        
        .explanation h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        .explanation p {
            line-height: 1.8;
            color: #34495e;
            font-size: 1.1em;
        }
        
        /* Interactive Demo */
        .demo-container {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 20px;
            padding: 40px;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
        }
        
        .demo-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }
        
        .demo-header {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            position: relative;
            z-index: 2;
        }
        
        .demo-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            position: relative;
            z-index: 2;
        }
        
        .demo-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            backdrop-filter: blur(10px);
        }
        
        .demo-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        
        .demo-btn:active {
            transform: translateY(-1px) scale(1.02);
        }
        
        .visualization-area {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 40px;
            min-height: 200px;
            position: relative;
            z-index: 2;
            overflow-x: auto;
        }
        
        .nodes-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            min-height: 120px;
            padding: 20px 0;
            position: relative;
        }
        
        .demo-node {
            display: flex;
            border: 3px solid #2c3e50;
            border-radius: 12px;
            overflow: hidden;
            background: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            transform-style: preserve-3d;
        }
        
        .demo-node:hover {
            transform: translateY(-8px) rotateY(5deg);
            box-shadow: 0 20px 40px rgba(0,0,0,0.25);
        }
        
        .demo-node.highlight {
            border-color: #e74c3c;
            animation: nodeHighlight 1s ease-in-out;
            box-shadow: 0 0 30px rgba(231, 76, 60, 0.5);
        }
        
        .demo-node.new {
            animation: nodeSlideIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .demo-node.removing {
            animation: nodeSlideOut 0.6s ease-in-out forwards;
        }
        
        .node-data {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 20px 25px;
            font-weight: bold;
            font-size: 1.3em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        
        .node-pointer {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            padding: 20px;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
        }
        
        .node-prev {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }
        
        .demo-arrow {
            font-size: 2.5em;
            color: #e74c3c;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            animation: arrowPulse 2s ease-in-out infinite;
            transition: all 0.3s ease;
        }
        
        .demo-arrow.highlight {
            color: #27ae60;
            animation: arrowGlow 1s ease-in-out;
            transform: scale(1.3);
        }
        
        /* Code Display */
        .code-container {
            background: #2c3e50;
            border-radius: 15px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
        }
        
        .code-header {
            background: linear-gradient(135deg, #34495e, #2c3e50);
            color: white;
            padding: 15px 25px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .code-header::before {
            content: '{ }';
            background: #e74c3c;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        .code-content {
            padding: 25px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            line-height: 1.8;
            color: #ecf0f1;
            overflow-x: auto;
        }
        
        .code-line {
            margin: 5px 0;
            position: relative;
            padding-left: 30px;
        }
        
        .code-line::before {
            content: counter(line-counter);
            counter-increment: line-counter;
            position: absolute;
            left: 0;
            color: #7f8c8d;
            font-size: 0.9em;
            width: 25px;
        }
        
        .code-content {
            counter-reset: line-counter;
        }
        
        .keyword { color: #3498db; font-weight: bold; }
        .type { color: #e74c3c; font-weight: bold; }
        .string { color: #2ecc71; }
        .comment { color: #95a5a6; font-style: italic; }
        .number { color: #f39c12; }
        .function { color: #9b59b6; }
        
        /* Features Grid */
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 40px 0;
        }
        
        .feature-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(240,248,255,0.9));
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.5);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .feature-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }
        
        .feature-card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }
        
        .feature-icon {
            font-size: 2.5em;
            margin-bottom: 15px;
            display: block;
        }
        
        .feature-title {
            color: #2c3e50;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .feature-content {
            color: #34495e;
            line-height: 1.6;
        }
        
        /* Comparison Table */
        .comparison-table {
            background: rgba(255,255,255,0.95);
            border-radius: 20px;
            padding: 40px;
            margin: 40px 0;
            overflow-x: auto;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }
        
        .table-container {
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 1.1em;
        }
        
        th, td {
            padding: 18px;
            text-align: center;
            border-bottom: 2px solid #ecf0f1;
            transition: all 0.3s ease;
        }
        
        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        
        tr:nth-child(even) {
            background: rgba(102, 126, 234, 0.05);
        }
        
        tr:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }
        
        td {
            position: relative;
        }
        
        /* Animations */
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes titleGlow {
            0%, 100% { text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
            50% { text-shadow: 2px 2px 20px rgba(255,255,255,0.5); }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-10px) rotate(5deg); }
            66% { transform: translateY(5px) rotate(-3deg); }
        }
        
        @keyframes colorFlow {
            0% { background-position: 0% 0%; }
            100% { background-position: 200% 0%; }
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes nodeHighlight {
            0%, 100% { box-shadow: 0 10px 30px rgba(0,0,0,0.15); }
            50% { box-shadow: 0 0 30px rgba(231, 76, 60, 0.8), 0 0 60px rgba(231, 76, 60, 0.4); }
        }
        
        @keyframes nodeSlideIn {
            0% {
                opacity: 0;
                transform: translateX(-100px) scale(0.5) rotateY(-90deg);
            }
            100% {
                opacity: 1;
                transform: translateX(0) scale(1) rotateY(0deg);
            }
        }
        
        @keyframes nodeSlideOut {
            0% {
                opacity: 1;
                transform: translateX(0) scale(1) rotateY(0deg);
            }
            100% {
                opacity: 0;
                transform: translateX(100px) scale(0.5) rotateY(90deg);
            }
        }
        
        @keyframes arrowPulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.3);
                opacity: 0.7;
            }
        }
        
        @keyframes arrowGlow {
            0%, 100% {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            }
            50% {
                text-shadow: 0 0 20px rgba(39, 174, 96, 0.8);
            }
        }
        
        /* Status Messages */
        .status-message {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            font-weight: bold;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }
        
        .status-message.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .status-message.error {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5em;
            }
            
            .content {
                padding: 20px;
            }
            
            .demo-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .nodes-container {
                flex-direction: column;
                gap: 15px;
            }
            
            .demo-arrow {
                transform: rotate(90deg);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔗 Danh sách liên kết</h1>
            <p>Khám phá cấu trúc dữ liệu qua demo tương tác và trực quan</p>
            
            <div class="nav-tabs">
                <button class="tab-btn active" onclick="showTab('singly')">Singly Linked List</button>
                <button class="tab-btn" onclick="showTab('doubly')">Doubly Linked List</button>
                <button class="tab-btn" onclick="showTab('circular')">Circular Linked List</button>
                <button class="tab-btn" onclick="showTab('comparison')">So sánh</button>
            </div>
        </div>
        
        <div class="content">
            <!-- Singly Linked List Tab -->
            <div id="singly" class="tab-content active">
                <div class="section">
                    <h2 class="section-title">📝 Danh sách liên kết đơn (Singly Linked List)</h2>
                    
                    <div class="explanation">
                        <h3>🎯 Khái niệm</h3>
                        <p>Danh sách liên kết đơn là một cấu trúc dữ liệu tuyến tính trong đó các phần tử (node) được liên kết với nhau thông qua con trỏ. Mỗi node chứa hai phần: <strong>data</strong> (dữ liệu) và <strong>next</strong> (con trỏ trỏ đến node tiếp theo). Node cuối cùng có con trỏ next trỏ đến NULL, đánh dấu kết thúc danh sách.</p>
                    </div>
                    
                    <div class="demo-container">
                        <div class="demo-header">
                            <h3>🎮 Demo tương tác</h3>
                            <p>Thử các hoạt động cơ bản trên danh sách liên kết đơn</p>
                        </div>
                        
                        <div class="demo-controls">
                            <button class="demo-btn" onclick="insertNode('singly')">➕ Thêm node</button>
                            <button class="demo-btn" onclick="deleteNode('singly')">❌ Xóa node</button>
                            <button class="demo-btn" onclick="searchNode('singly')">🔍 Tìm kiếm</button>
                            <button class="demo-btn" onclick="traverseList('singly')">👉 Duyệt danh sách</button>
                            <button class="demo-btn" onclick="resetList('singly')">🔄 Reset</button>
                        </div>
                        
                        <div class="visualization-area">
                            <div id="singly-nodes" class="nodes-container">
                                <!-- Nodes will be generated here -->
                            </div>
                        </div>
                        
                        <div id="singly-status" class="status-message"></div>
                    </div>
                    
                    <div class="code-container">
                        <div class="code-header">Code mẫu - Singly Linked List</div>
                        <div class="code-content">
                            <div class="code-line"><span class="comment">// Định nghĩa cấu trúc Node</span></div>
                            <div class="code-line"><span class="keyword">struct</span> <span class="type">Node</span> {</div>
                            <div class="code-line">    <span class="type">int</span> data;        <span class="comment">// Dữ liệu</span></div>
                            <div class="code-line">    <span class="type">Node*</span> next;      <span class="comment">// Con trỏ đến node tiếp theo</span></div>
                            <div class="code-line">};</div>
                            <div class="code-line"></div>
                            <div class="code-line"><span class="comment">// Thêm node vào đầu danh sách</span></div>
                            <div class="code-line"><span class="type">void</span> <span class="function">insertAtHead</span>(<span class="type">Node*&</span> head, <span class="type">int</span> value) {</div>
                            <div class="code-line">    <span class="type">Node*</span> newNode = <span class="keyword">new</span> <span class="type">Node</span>();</div>
                            <div class="code-line">    newNode->data = value;</div>
                            <div class="code-line">    newNode->next = head;</div>
                            <div class="code-line">    head = newNode;</div>
                            <div class="code-line">}</div>
                            <div class="code-line"></div>
                            <div class="code-line"><span class="comment">// Xóa node có giá trị cho trước</span></div>
                            <div class="code-line"><span class="type">void</span> <span class="function">deleteNode</span>(<span class="type">Node*&</span> head, <span class="type">int</span> value) {</div>
                            <div class="code-line">    <span class="keyword">if</span> (head == <span class="keyword">nullptr</span>) <span class="keyword">return</span>;</div>
                            <div class="code-line">    </div>
                            <div class="code-line">    <span class="keyword">if</span> (head->data == value) {</div>
                            <div class="code-line">        <span class="type">Node*</span> temp = head;</div>
                            <div class="code-line">        head = head->next;</div>
                            <div class="code-line">        <span class="keyword">delete</span> temp;</div>
                            <div class="code-line">        <span class="keyword">return</span>;</div>
                            <div class="code-line">    }</div>
                            <div class="code-line">    </div>
                            <div class="code-line">    <span class="type">Node*</span> current = head;</div>
                            <div class="code-line">    <span class="keyword">while</span> (current->next && current->next->data != value) {</div>
                            <div class="code-line">        current = current->next;</div>
                            <div class="code-line">    }</div>
                            <div class="code-line">    </div>
                            <div class="code-line">    <span class="keyword">if</span> (current->next) {</div>
                            <div class="code-line">        <span class="type">Node*</span> temp = current->next;</div>
                            <div class="code-line">        current->next = current->next->next;</div>
                            <div class="code-line">        <span class="keyword">delete</span> temp;</div>
                            <div class="code-line">    }</div>
                            <div class="code-line">}</div>
                        </div>
                    </div>
                    
                    <div class="features-grid">
                        <div class="feature-card">
                            <span class="feature-icon">✅</span>
                            <div class="feature-title">Ưu điểm</div>
                            <div class="feature-content">
                                • Tiết kiệm bộ nhớ (chỉ 1 con trỏ)<br>
                                • Cài đặt đơn giản<br>
                                • Thêm/xóa đầu danh sách O(1)<br>
                                • Kích thước động
                            </div>
                        </div>
                        <div class="feature-card">
                            <span class="feature-icon">❌</span>
                            <div class="feature-title">Nhược điểm</div>
                            <div class="feature-content">
                                • Không thể duyệt ngược<br>
                                • Truy cập tuần tự O(n)<br>
                                • Xóa node cần biết node trước<br>
                                • Không thể truy cập ngẫu nhiên
                            </div>
                        </div>
                        <div class="feature-card">
                            <span class="feature-icon">🎯</span>
                            <div class="feature-title">Ứng dụng</div>
                            <div class="feature-content">
                                • Cài đặt Stack và Queue<br>
                                • Biểu diễn đa thức<br>
                                • Undo operations<br>
                                • Music playlists
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Doubly Linked List Tab -->
            <div id="doubly" class="tab-content">
                <div class="section">
                    <h2 class="section-title">🔄 Danh sách liên kết đôi (Doubly Linked List)</h2>
                    
                    <div class="explanation">
                        <h3>🎯 Khái niệm</h3>
                        <p>Danh sách liên kết đôi là phiên bản cải tiến của danh sách liên kết đơn. Mỗi node có ba phần: <strong>prev</strong> (con trỏ đến node trước), <strong>data</strong> (dữ liệu), và <strong>next</strong> (con trỏ đến node sau). Điều này cho phép duyệt danh sách theo cả hai hướng: tiến và lùi.</p>
                    </div>
                    
                    <div class="demo-container">
                        <div class="demo-header">
                            <h3>🎮 Demo tương tác - Doubly Linked List</h3>
                            <p>Khám phá khả năng duyệt hai chiều</p>
                        </div>
                        
                        <div class="demo-controls">
                            <button class="demo-btn" onclick="insertNode('doubly')">➕ Thêm node</button>
                            <button class="demo-btn" onclick="deleteNode('doubly')">❌ Xóa node</button>
                            <button class="demo-btn" onclick="traverseForward('doubly')">➡️ Duyệt tiến</button>
                            <button class="demo-btn" onclick="traverseBackward('doubly')">⬅️ Duyệt lùi</button>
                            <button class="demo-btn" onclick="resetList('doubly')">🔄 Reset</button>
                        </div>
                        
                        <div class="visualization-area">
                            <div id="doubly-nodes" class="nodes-container">
                                <!-- Nodes will be generated here -->
                            </div>
                        </div>
                        
                        <div id="doubly-status" class="status-message"></div>
                    </div>
                    
                    <div class="code-container">
                        <div class="code-header">Code mẫu - Doubly Linked List</div>
                        <div class="code-content">
                            <div class="code-line"><span class="comment">// Định nghĩa cấu trúc Node cho Doubly Linked List</span></div>
                            <div class="code-line"><span class="keyword">struct</span> <span class="type">DNode</span> {</div>
                            <div class="code-line">    <span class="type">int</span> data;        <span class="comment">// Dữ liệu</span></div>
                            <div class="code-line">    <span class="type">DNode*</span> prev;     <span class="comment">// Con trỏ đến node trước</span></div>
                            <div class="code-line">    <span class="type">DNode*</span> next;     <span class="comment">// Con trỏ đến node sau</span></div>
                            <div class="code-line">};</div>
                            <div class="code-line"></div>
                            <div class="code-line"><span class="comment">// Thêm node vào đầu danh sách</span></div>
                            <div class="code-line"><span class="type">void</span> <span class="function">insertAtHead</span>(<span class="type">DNode*&</span> head, <span class="type">int</span> value) {</div>
                            <div class="code-line">    <span class="type">DNode*</span> newNode = <span class="keyword">new</span> <span class="type">DNode</span>();</div>
                            <div class="code-line">    newNode->data = value;</div>
                            <div class="code-line">    newNode->prev = <span class="keyword">nullptr</span>;</div>
                            <div class="code-line">    newNode->next = head;</div>
                            <div class="code-line">    </div>
                            <div class="code-line">    <span class="keyword">if</span> (head != <span class="keyword">nullptr</span>) {</div>
                            <div class="code-line">        head->prev = newNode;</div>
                            <div class="code-line">    }</div>
                            <div class="code-line">    head = newNode;</div>
                            <div class="code-line">}</div>
                            <div class="code-line"></div>
                            <div class="code-line"><span class="comment">// Duyệt danh sách theo chiều tiến</span></div>
                            <div class="code-line"><span class="type">void</span> <span class="function">traverseForward</span>(<span class="type">DNode*</span> head) {</div>
                            <div class="code-line">    <span class="type">DNode*</span> current = head;</div>
                            <div class="code-line">    <span class="keyword">while</span> (current != <span class="keyword">nullptr</span>) {</div>
                            <div class="code-line">        cout << current->data << <span class="string">" "</span>;</div>
                            <div class="code-line">        current = current->next;</div>
                            <div class="code-line">    }</div>
                            <div class="code-line">}</div>
                            <div class="code-line"></div>
                            <div class="code-line"><span class="comment">// Duyệt danh sách theo chiều lùi</span></div>
                            <div class="code-line"><span class="type">void</span> <span class="function">traverseBackward</span>(<span class="type">DNode*</span> tail) {</div>
                            <div class="code-line">    <span class="type">DNode*</span> current = tail;</div>
                            <div class="code-line">    <span class="keyword">while</span> (current != <span class="keyword">nullptr</span>) {</div>
                            <div class="code-line">        cout << current->data << <span class="string">" "</span>;</div>
                            <div class="code-line">        current = current->prev;</div>
                            <div class="code-line">    }</div>
                            <div class="code-line">}</div>
                        </div>
                    </div>
                    
                    <div class="features-grid">
                        <div class="feature-card">
                            <span class="feature-icon">✅</span>
                            <div class="feature-title">Ưu điểm</div>
                            <div class="feature-content">
                                • Duyệt hai chiều (tiến và lùi)<br>
                                • Xóa node dễ dàng hơn<br>
                                • Chèn vào giữa hiệu quả<br>
                                • Navigation linh hoạt
                            </div>
                        </div>
                        <div class="feature-card">
                            <span class="feature-icon">❌</span>
                            <div class="feature-title">Nhược điểm</div>
                            <div class="feature-content">
                                • Tốn nhiều bộ nhớ (2 con trỏ)<br>
                                • Cài đặt phức tạp hơn<br>
                                • Cần quản lý cả prev và next<br>
                                • Overhead cao hơn
                            </div>
                        </div>
                        <div class="feature-card">
                            <span class="feature-icon">🎯</span>
                            <div class="feature-title">Ứng dụng</div>
                            <div class="feature-content">
                                • Trình duyệt web (Back/Forward)<br>
                                • Text Editor (Undo/Redo)<br>
                                • Music Player (Previous/Next)<br>
                                • LRU Cache implementation
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Circular Linked List Tab -->
            <div id="circular" class="tab-content">
                <div class="section">
                    <h2 class="section-title">🔄 Danh sách liên kết vòng (Circular Linked List)</h2>
                    
                    <div class="explanation">
                        <h3>🎯 Khái niệm</h3>
                        <p>Danh sách liên kết vòng là biến thể đặc biệt trong đó node cuối cùng không trỏ đến NULL mà trỏ trở lại node đầu tiên, tạo thành một vòng tròn khép kín. Điều này cho phép duyệt danh sách một cách liên tục và vô hạn.</p>
                    </div>
                    
                    <div class="demo-container">
                        <div class="demo-header">
                            <h3>🎮 Demo tương tác - Circular Linked List</h3>
                            <p>Khám phá tính chất vòng tròn của cấu trúc</p>
                        </div>
                        
                        <div class="demo-controls">
                            <button class="demo-btn" onclick="insertNode('circular')">➕ Thêm node</button>
                            <button class="demo-btn" onclick="deleteNode('circular')">❌ Xóa node</button>
                            <button class="demo-btn" onclick="traverseCircular('circular')">🔄 Duyệt vòng</button>
                            <button class="demo-btn" onclick="showCircularPath('circular')">👁️ Hiện đường vòng</button>
                            <button class="demo-btn" onclick="resetList('circular')">🔄 Reset</button>
                        </div>
                        
                        <div class="visualization-area">
                            <div id="circular-nodes" class="nodes-container">
                                <!-- Nodes will be generated here -->
                            </div>
                        </div>
                        
                        <div id="circular-status" class="status-message"></div>
                    </div>
                    
                    <div class="code-container">
                        <div class="code-header">Code mẫu - Circular Linked List</div>
                        <div class="code-content">
                            <div class="code-line"><span class="comment">// Cấu trúc node cho Circular Linked List</span></div>
                            <div class="code-line"><span class="keyword">struct</span> <span class="type">CNode</span> {</div>
                            <div class="code-line">    <span class="type">int</span> data;</div>
                            <div class="code-line">    <span class="type">CNode*</span> next;     <span class="comment">// Node cuối trỏ về head</span></div>
                            <div class="code-line">};</div>
                            <div class="code-line"></div>
                            <div class="code-line"><span class="comment">// Thêm node vào danh sách vòng</span></div>
                            <div class="code-line"><span class="type">void</span> <span class="function">insertInCircular</span>(<span class="type">CNode*&</span> head, <span class="type">int</span> value) {</div>
                            <div class="code-line">    <span class="type">CNode*</span> newNode = <span class="keyword">new</span> <span class="type">CNode</span>();</div>
                            <div class="code-line">    newNode->data = value;</div>
                            <div class="code-line">    </div>
                            <div class="code-line">    <span class="keyword">if</span> (head == <span class="keyword">nullptr</span>) {</div>
                            <div class="code-line">        head = newNode;</div>
                            <div class="code-line">        newNode->next = head;  <span class="comment">// Trỏ về chính nó</span></div>
                            <div class="code-line">    } <span class="keyword">else</span> {</div>
                            <div class="code-line">        <span class="comment">// Tìm node cuối</span></div>
                            <div class="code-line">        <span class="type">CNode*</span> current = head;</div>
                            <div class="code-line">        <span class="keyword">while</span> (current->next != head) {</div>
                            <div class="code-line">            current = current->next;</div>
                            <div class="code-line">        }</div>
                            <div class="code-line">        </div>
                            <div class="code-line">        <span class="comment">// Chèn node mới</span></div>
                            <div class="code-line">        current->next = newNode;</div>
                            <div class="code-line">        newNode->next = head;</div>
                            <div class="code-line">    }</div>
                            <div class="code-line">}</div>
                            <div class="code-line"></div>
                            <div class="code-line"><span class="comment">// Duyệt danh sách vòng (với giới hạn)</span></div>
                            <div class="code-line"><span class="type">void</span> <span class="function">traverseCircular</span>(<span class="type">CNode*</span> head, <span class="type">int</span> rounds) {</div>
                            <div class="code-line">    <span class="keyword">if</span> (head == <span class="keyword">nullptr</span>) <span class="keyword">return</span>;</div>
                            <div class="code-line">    </div>
                            <div class="code-line">    <span class="type">CNode*</span> current = head;</div>
                            <div class="code-line">    <span class="type">int</span> count = <span class="number">0</span>;</div>
                            <div class="code-line">    </div>
                            <div class="code-line">    <span class="keyword">do</span> {</div>
                            <div class="code-line">        cout << current->data << <span class="string">" "</span>;</div>
                            <div class="code-line">        current = current->next;</div>
                            <div class="code-line">        count++;</div>
                            <div class="code-line">    } <span class="keyword">while</span> (current != head && count < rounds);</div>
                            <div class="code-line">}</div>
                        </div>
                    </div>
                    
                    <div class="features-grid">
                        <div class="feature-card">
                            <span class="feature-icon">✅</span>
                            <div class="feature-title">Ưu điểm</div>
                            <div class="feature-content">
                                • Duyệt vô hạn, liên tục<br>
                                • Không có NULL pointer<br>
                                • Phù hợp Round-Robin<br>
                                • Tiết kiệm trong một số ứng dụng
                            </div>
                        </div>
                        <div class="feature-card">
                            <span class="feature-icon">❌</span>
                            <div class="feature-title">Nhược điểm</div>
                            <div class="feature-content">
                                • Dễ tạo vòng lặp vô hạn<br>
                                • Khó kiểm soát điều kiện dừng<br>
                                • Debug phức tạp<br>
                                • Cần cẩn thận khi xử lý
                            </div>
                        </div>
                        <div class="feature-card">
                            <span class="feature-icon">🎯</span>
                            <div class="feature-title">Ứng dụng</div>
                            <div class="feature-content">
                                • Game turn-based<br>
                                • Round-robin scheduling<br>
                                • Buffer vòng (Ring buffer)<br>
                                • Josephus problem
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Comparison Tab -->
            <div id="comparison" class="tab-content">
                <div class="section">
                    <h2 class="section-title">📊 So sánh chi tiết các loại danh sách liên kết</h2>
                    
                    <div class="comparison-table">
                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Tiêu chí</th>
                                        <th>Singly Linked</th>
                                        <th>Doubly Linked</th>
                                        <th>Circular Linked</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Cấu trúc Node</strong></td>
                                        <td>[data | next]</td>
                                        <td>[prev | data | next]</td>
                                        <td>[data | next] ↻</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Bộ nhớ/Node</strong></td>
                                        <td>8 bytes (64-bit)</td>
                                        <td>16 bytes (64-bit)</td>
                                        <td>8 bytes (64-bit)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Hướng duyệt</strong></td>
                                        <td>Một chiều (→)</td>
                                        <td>Hai chiều (↔)</td>
                                        <td>Vòng tròn (↻)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Thêm đầu</strong></td>
                                        <td>O(1)</td>
                                        <td>O(1)</td>
                                        <td>O(1)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Thêm cuối</strong></td>
                                        <td>O(n)</td>
                                        <td>O(1) với tail pointer</td>
                                        <td>O(n) hoặc O(1) với tail</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Xóa node</strong></td>
                                        <td>O(n)</td>
                                        <td>O(1) nếu có con trỏ</td>
                                        <td>O(n)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Tìm kiếm</strong></td>
                                        <td>O(n)</td>
                                        <td>O(n)</td>
                                        <td>O(n)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Độ phức tạp cài đặt</strong></td>
                                        <td>Đơn giản</td>
                                        <td>Trung bình</td>
                                        <td>Trung bình</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Ứng dụng chính</strong></td>
                                        <td>Stack, Queue đơn giản</td>
                                        <td>Browser history, LRU Cache</td>
                                        <td>Round-robin, Games</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="explanation">
                        <h3>🎯 Khi nào nên sử dụng loại nào?</h3>
                        <div class="features-grid">
                            <div class="feature-card">
                                <span class="feature-icon">📝</span>
                                <div class="feature-title">Singly Linked List</div>
                                <div class="feature-content">
                                    <strong>Sử dụng khi:</strong><br>
                                    • Chỉ cần duyệt một chiều<br>
                                    • Tiết kiệm bộ nhớ là ưu tiên<br>
                                    • Cài đặt Stack, Queue đơn giản<br>
                                    • Ứng dụng không cần navigation phức tạp
                                </div>
                            </div>
                            <div class="feature-card">
                                <span class="feature-icon">🔄</span>
                                <div class="feature-title">Doubly Linked List</div>
                                <div class="feature-content">
                                    <strong>Sử dụng khi:</strong><br>
                                    • Cần duyệt hai chiều<br>
                                    • Thao tác xóa/chèn giữa thường xuyên<br>
                                    • Ứng dụng có Back/Forward navigation<br>
                                    • Cần Undo/Redo functionality
                                </div>
                            </div>
                            <div class="feature-card">
                                <span class="feature-icon">🔁</span>
                                <div class="feature-title">Circular Linked List</div>
                                <div class="feature-content">
                                    <strong>Sử dụng khi:</strong><br>
                                    • Cần lặp vô hạn qua dữ liệu<br>
                                    • Round-robin scheduling<br>
                                    • Game có lượt chơi tuần tự<br>
                                    • Ring buffer implementations
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global data structures for each list type
        const listData = {
            singly: [10, 20, 30],
            doubly: [10, 20, 30],
            circular: [10, 20, 30]
        };
        
        let currentHighlight = null;
        let isTraversing = false;
        
        // Tab switching
        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            // Render the list for the current tab
            renderList(tabName);
        }
        
        // Render list visualization
        function renderList(type) {
            const container = document.getElementById(`${type}-nodes`);
            if (!container) return;
            
            container.innerHTML = '';
            const data = listData[type];
            
            if (data.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d; font-size: 1.2em;">Danh sách trống</div>';
                return;
            }
            
            // Add HEAD pointer
            const headNode = document.createElement('div');
            headNode.className = 'demo-node';
            headNode.innerHTML = `
                <div class="node-data" style="background: linear-gradient(135deg, #e74c3c, #c0392b);">HEAD</div>
            `;
            container.appendChild(headNode);
            
            // Add arrow after HEAD
            const headArrow = document.createElement('div');
            headArrow.className = 'demo-arrow';
            headArrow.textContent = '→';
            container.appendChild(headArrow);
            
            // Add data nodes
            data.forEach((value, index) => {
                const node = document.createElement('div');
                node.className = 'demo-node';
                node.dataset.index = index;
                
                if (type === 'doubly') {
                    node.innerHTML = `
                        <div class="node-pointer node-prev">←</div>
                        <div class="node-data">${value}</div>
                        <div class="node-pointer">→</div>
                    `;
                } else {
                    node.innerHTML = `
                        <div class="node-data">${value}</div>
                        <div class="node-pointer">${type === 'circular' && index === data.length - 1 ? '↻' : '→'}</div>
                    `;
                }
                
                container.appendChild(node);
                
                // Add arrow between nodes (except for last node in non-circular lists)
                if (index < data.length - 1 || type === 'circular') {
                    const arrow = document.createElement('div');
                    arrow.className = 'demo-arrow';
                    
                    if (type === 'doubly') {
                        arrow.innerHTML = '<div style="color: #e74c3c;">→</div><div style="color: #f39c12;">←</div>';
                    } else if (type === 'circular' && index === data.length - 1) {
                        arrow.textContent = '↻';
                        arrow.style.color = '#27ae60';
                    } else {
                        arrow.textContent = '→';
                    }
                    
                    container.appendChild(arrow);
                }
            });
            
            // Add NULL for non-circular lists
            if (type !== 'circular') {
                const nullNode = document.createElement('div');
                nullNode.className = 'demo-node';
                nullNode.innerHTML = '<div class="node-data" style="background: linear-gradient(135deg, #95a5a6, #7f8c8d);">NULL</div>';
                container.appendChild(nullNode);
            }
        }
        
        // Show status message
        function showStatus(type, message, isError = false) {
            const statusElement = document.getElementById(`${type}-status`);
            if (!statusElement) return;
            
            statusElement.textContent = message;
            statusElement.className = `status-message show ${isError ? 'error' : ''}`;
            
            setTimeout(() => {
                statusElement.classList.remove('show');
            }, 3000);
        }
        
        // Insert node operation
        function insertNode(type) {
            if (isTraversing) return;
            
            const newValue = Math.floor(Math.random() * 90) + 10;
            listData[type].unshift(newValue);
            
            showStatus(type, `✅ Đã thêm node với giá trị ${newValue} vào đầu danh sách`);
            renderList(type);
            
            // Highlight new node
            setTimeout(() => {
                const newNode = document.querySelector(`#${type}-nodes .demo-node[data-index="0"]`);
                if (newNode) {
                    newNode.classList.add('new');
                }
            }, 100);
        }
        
        // Delete node operation
        function deleteNode(type) {
            if (isTraversing) return;
            
            if (listData[type].length === 0) {
                showStatus(type, '❌ Danh sách trống, không thể xóa!', true);
                return;
            }
            
            const removedValue = listData[type].shift();
            showStatus(type, `🗑️ Đã xóa node có giá trị ${removedValue}`);
            renderList(type);
        }
        
        // Search node operation
        function searchNode(type) {
            if (isTraversing) return;
            
            if (listData[type].length === 0) {
                showStatus(type, '❌ Danh sách trống!', true);
                return;
            }
            
            const targetValue = listData[type][Math.floor(Math.random() * listData[type].length)];
            isTraversing = true;
            
            showStatus(type, `🔍 Đang tìm kiếm giá trị ${targetValue}...`);
            
            const nodes = document.querySelectorAll(`#${type}-nodes .demo-node[data-index]`);
            let currentIndex = 0;
            
            const searchInterval = setInterval(() => {
                // Remove previous highlight
                nodes.forEach(node => node.classList.remove('highlight'));
                
                if (currentIndex < nodes.length) {
                    nodes[currentIndex].classList.add('highlight');
                    
                    const nodeValue = parseInt(nodes[currentIndex].querySelector('.node-data').textContent);
                    if (nodeValue === targetValue) {
                        clearInterval(searchInterval);
                        showStatus(type, `✅ Tìm thấy giá trị ${targetValue} tại vị trí ${currentIndex + 1}!`);
                        isTraversing = false;
                        
                        setTimeout(() => {
                            nodes[currentIndex].classList.remove('highlight');
                        }, 2000);
                        return;
                    }
                    currentIndex++;
                } else {
                    clearInterval(searchInterval);
                    showStatus(type, `❌ Không tìm thấy giá trị ${targetValue}!`, true);
                    isTraversing = false;
                }
            }, 800);
        }
        
        // Traverse list operation
        function traverseList(type) {
            if (isTraversing) return;
            
            if (listData[type].length === 0) {
                showStatus(type, '❌ Danh sách trống!', true);
                return;
            }
            
            isTraversing = true;
            showStatus(type, '👉 Đang duyệt danh sách...');
            
            const nodes = document.querySelectorAll(`#${type}-nodes .demo-node[data-index]`);
            const arrows = document.querySelectorAll(`#${type}-nodes .demo-arrow`);
            let currentIndex = 0;
            
            const traverseInterval = setInterval(() => {
                // Remove previous highlights
                nodes.forEach(node => node.classList.remove('highlight'));
                arrows.forEach(arrow => arrow.classList.remove('highlight'));
                
                if (currentIndex < nodes.length) {
                    nodes[currentIndex].classList.add('highlight');
                    if (currentIndex < arrows.length - 1) {
                        arrows[currentIndex + 1].classList.add('highlight');
                    }
                    currentIndex++;
                } else {
                    clearInterval(traverseInterval);
                    showStatus(type, '✅ Hoàn thành duyệt danh sách!');
                    isTraversing = false;
                    
                    // Clean up highlights
                    setTimeout(() => {
                        nodes.forEach(node => node.classList.remove('highlight'));
                        arrows.forEach(arrow => arrow.classList.remove('highlight'));
                    }, 1000);
                }
            }, 1000);
        }
        
        // Traverse forward for doubly linked list
        function traverseForward(type) {
            traverseList(type);
        }
        
        // Traverse backward for doubly linked list
        function traverseBackward(type) {
            if (isTraversing) return;
            
            if (listData[type].length === 0) {
                showStatus(type, '❌ Danh sách trống!', true);
                return;
            }
            
            isTraversing = true;
            showStatus(type, '⬅️ Đang duyệt ngược danh sách...');
            
            const nodes = document.querySelectorAll(`#${type}-nodes .demo-node[data-index]`);
            let currentIndex = nodes.length - 1;
            
            const traverseInterval = setInterval(() => {
                // Remove previous highlights
                nodes.forEach(node => node.classList.remove('highlight'));
                
                if (currentIndex >= 0) {
                    nodes[currentIndex].classList.add('highlight');
                    currentIndex--;
                } else {
                    clearInterval(traverseInterval);
                    showStatus(type, '✅ Hoàn thành duyệt ngược danh sách!');
                    isTraversing = false;
                    
                    // Clean up highlights
                    setTimeout(() => {
                        nodes.forEach(node => node.classList.remove('highlight'));
                    }, 1000);
                }
            }, 1000);
        }
        
        // Traverse circular list
        function traverseCircular(type) {
            if (isTraversing) return;
            
            if (listData[type].length === 0) {
                showStatus(type, '❌ Danh sách trống!', true);
                return;
            }
            
            isTraversing = true;
            showStatus(type, '🔄 Đang duyệt danh sách vòng (2 vòng)...');
            
            const nodes = document.querySelectorAll(`#${type}-nodes .demo-node[data-index]`);
            let currentIndex = 0;
            let rounds = 0;
            const maxRounds = 2;
            
            const traverseInterval = setInterval(() => {
                // Remove previous highlights
                nodes.forEach(node => node.classList.remove('highlight'));
                
                if (rounds < maxRounds) {
                    nodes[currentIndex].classList.add('highlight');
                    currentIndex++;
                    
                    if (currentIndex >= nodes.length) {
                        currentIndex = 0;
                        rounds++;
                    }
                } else {
                    clearInterval(traverseInterval);
                    showStatus(type, `✅ Hoàn thành ${maxRounds} vòng duyệt!`);
                    isTraversing = false;
                    
                    // Clean up highlights
                    setTimeout(() => {
                        nodes.forEach(node => node.classList.remove('highlight'));
                    }, 1000);
                }
            }, 800);
        }
        
        // Show circular path
        function showCircularPath(type) {
            showStatus(type, '👁️ Hiển thị đường vòng của danh sách liên kết vòng');
            
            // Add visual effect to show the circular connection
            const container = document.getElementById(`${type}-nodes`);
            const lastArrow = container.querySelector('.demo-arrow:last-child');
            if (lastArrow) {
                lastArrow.style.animation = 'arrowGlow 2s ease-in-out 3';
                lastArrow.style.color = '#27ae60';
                lastArrow.style.fontSize = '3em';
                
                setTimeout(() => {
                    lastArrow.style.animation = '';
                    lastArrow.style.color = '';
                    lastArrow.style.fontSize = '';
                }, 6000);
            }
        }
        
        // Reset list
        function resetList(type) {
            if (isTraversing) return;
            
            listData[type] = [10, 20, 30];
            showStatus(type, '🔄 Đã reset danh sách về trạng thái ban đầu');
            renderList(type);
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            renderList('singly');
        });
    </script>
</body>
</html>